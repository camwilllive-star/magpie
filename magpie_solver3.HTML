<!doctype html>
<html lang="en">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Mr. Magpie â€” Touch (Minimal)</title>
<style>
  :root{--bg:#0b1220;--fg:#e6edf3;--mut:#9aa4b2;--card:#111827;--line:#233047;--hi:#fde047;}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif}
  .wrap{max-width:980px;margin:0 auto;padding:12px}
  .row{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:12px}
  .btn{background:#1d4ed8;border:none;color:#fff;border-radius:10px;padding:10px 14px;font-weight:700}
  .btn:disabled{opacity:.5}
  input,select{background:#0b1220;color:var(--fg);border:1px solid var(--line);border-radius:8px;padding:8px}
  label{font-size:.9em;color:var(--mut)}
  .grid{display:grid;gap:6px}
  .tile{width:54px;height:54px;border-radius:10px;border:1px solid var(--line);display:flex;align-items:center;justify-content:center;font-weight:800;font-size:18px;user-select:none;position:relative}
  .tile.unknown{background:#0d1526;color:#cbd5e1}
  .tile.jerry{background:#7f1d1d}
  .tile.money{background:#14532d}
  .tile.hint{background:#1e3a8a}
  .tile.reac{background:#3f1d7a}
  .tile.eye{background:#6b21a8}
  .tile.mult{background:#7c2d12}
  .tile.blank{background:#0b1220;border-style:dashed}
  .prob{font-size:12px;opacity:.95;position:absolute;bottom:4px;right:6px;text-shadow:0 1px 2px rgba(0,0,0,.5)}
  .hi{outline:3px solid var(--hi)}
  /* quick tool buttons */
  .toolbar{display:flex;gap:8px;flex-wrap:wrap}
  .tool{background:#0b1220;border:1px solid var(--line);color:var(--fg);border-radius:10px;padding:10px 14px;font-weight:800;min-width:48px;text-align:center}
  .tool.active{outline:3px solid #22c55e}
</style>
<body>
<div class="wrap">
  <h1>Mr. Magpie â€” Touch (Minimal)</h1>

  <div class="card row">
    <div><label>Rows<br><input id="rows" type="number" min="1" max="26" value="3"></label></div>
    <div><label>Cols<br><input id="cols" type="number" min="1" max="40" value="8"></label></div>
    <div><label>Total JERRYs<br><input id="totalJ" type="number" min="0" value="4"></label></div>
    <div style="align-self:end"><button id="apply" class="btn">Apply Board</button></div>
    <div><label>Tap Mode<br>
      <select id="mode">
        <option value="cycle">Cycle Types</option>
        <option value="place">Place Selected</option>
      </select></label>
    </div>
    <div><label>Selected Type<br>
      <select id="placeType">
        <option value="UNKNOWN">. UNKNOWN</option>
        <option value="MONEY">$ MONEY</option>
        <option value="JERRY">X JERRY</option>
        <option value="HINT">H HINT</option>
        <option value="REACTIVATOR">R REACTIVATOR</option>
        <option value="EYE">E EYE</option>
        <option value="MULTIPLIER">M MULTIPLIER</option>
        <option value="BLANK">_ BLANK</option>
      </select></label>
    </div>
  </div>

  <!-- Quick tool buttons (includes Eyedropper) -->
  <div class="card">
    <div class="toolbar">
      <button class="tool" id="toolPick">ðŸ”Ž</button>
      <button class="tool" id="toolDot">.</button>
      <button class="tool" id="toolMoney">$</button>
      <button class="tool" id="toolJerry">X</button>
      <button class="tool" id="toolHint">H</button>
      <button class="tool" id="toolReac">R</button>
      <button class="tool" id="toolEye">E</button>
      <button class="tool" id="toolMult">M</button>
      <button class="tool" id="toolBlank">_</button>
    </div>
    <div style="margin-top:6px;color:#9aa4b2;font-size:.9em">
      Tap a tool (e.g. <b>$</b> or <b>ðŸ”Ž</b>), then tap cells. Eyedropper (ðŸ”Ž) picks the tapped cellâ€™s type as the active tool.
    </div>
  </div>

  <div class="card row" id="hintBox">
    <div><label>Hint Type<br>
      <select id="hintType">
        <option value="no_adjacent">no_adjacent</option>
        <option value="exists_row_empty">exists_row_empty</option>
        <option value="each_row_at_least_one">each_row_at_least_one</option>
        <option value="row_count">row_count</option>
        <option value="col_count">col_count</option>
        <option value="num_columns_with_jerry">num_columns_with_jerry</option>
        <option value="adjacent_count">adjacent_count</option>
        <option value="adjacent_to_eyes_total">adjacent_to_eyes_total</option>
        <option value="corner_count">corner_count</option>
        <option value="largest_grouping">largest_grouping</option>
        <option value="all_in_3x3">all_in_3x3</option>
        <option value="more_left_than_right">more_left_than_right</option>
        <option value="more_right_than_left">more_right_than_left</option>
        <option value="more_up_than_down">more_up_than_down</option>
        <option value="more_down_than_up">more_down_than_up</option>
      </select></label>
    </div>
    <div id="hintParams"></div>
    <div style="align-self:end"><button id="addHint" class="btn">Add Hint</button></div>
    <div style="flex:1 1 100%">
      <label>Active Hints</label>
      <div id="hintList" class="row"></div>
    </div>
  </div>

  <div class="card">
    <div class="row">
      <div><label>Samples<br><input id="samples" type="number" min="1" value="800"></label></div>
      <div style="align-self:end"><button id="run" class="btn">Run Solver</button></div>
      <div id="hit" style="align-self:end;color:#9aa4b2"></div>
      <div><label># Picks<br><input id="k" type="number" min="1" value="3"></label></div>
      <div style="align-self:end"><button id="picksBtn" class="btn" style="background:#15803d">Show Picks</button></div>
      <div style="align-self:end"><button id="wipe" class="btn" style="background:#dc2626">Wipe</button></div>
    </div>
    <div id="grid" class="grid"></div>
    <div id="picks" class="row" style="margin-top:8px"></div>
  </div>
</div>

<script>
/* ===== Model & Types ===== */
const CARD={UNKNOWN:"UNKNOWN",MONEY:"MONEY",JERRY:"JERRY",HINT:"HINT",REACTIVATOR:"REACTIVATOR",EYE:"EYE",MULTIPLIER:"MULTIPLIER",BLANK:"BLANK"};
const SYM={UNKNOWN:".",MONEY:"$",JERRY:"X",HINT:"H",REACTIVATOR:"R",EYE:"E",MULTIPLIER:"M",BLANK:"_"};
let R=3,C=8,TOTAL=4; let G=[]; let hints=[]; let PROB=null;

/* ===== Utilities ===== */
function makeG(){ G=[...Array(R)].map(()=>[...Array(C)].map(()=>CARD.UNKNOWN)); }
function css(t){ return {UNKNOWN:"unknown",JERRY:"jerry",MONEY:"money",HINT:"hint",REACTIVATOR:"reac",EYE:"eye",MULTIPLIER:"mult",BLANK:"blank"}[t]||"unknown"; }
function neighbors8(r,c){ const out=[]; for(let dr=-1;dr<=1;dr++)for(let dc=-1;dc<=1;dc++){ if(!dr&&!dc)continue; const nr=r+dr,nc=c+dc; if(nr>=0&&nr<R&&nc>=0&&nc<C) out.push([nr,nc]); } return out; }
function toCoord(r,c){return String.fromCharCode(65+r)+(c+1)}
function parseCell(s){
  s=s.trim();
  let m=s.match(/^([A-Za-z])(\d+)$/); if(m){let rr=m[1].toUpperCase().charCodeAt(0)-65,cc=+m[2]-1; if(rr<0||rr>=R||cc<0||cc>=C) throw Error("range"); return [rr,cc];}
  let p=s.split(/\s+/); if(p.length===2&&/^\d+$/.test(p[0])&&/^\d+$/.test(p[1])){let rr=+p[0],cc=+p[1]; if(rr<0||rr>=R||cc<0||cc>=C) throw Error("range"); return [rr,cc];}
  throw Error("cell");
}
function cycle(t){ const a=[CARD.UNKNOWN,CARD.MONEY,CARD.JERRY,CARD.HINT,CARD.REACTIVATOR,CARD.EYE,CARD.MULTIPLIER,CARD.BLANK]; return a[(a.indexOf(t)+1)%a.length]; }
function key(r,c){return r+","+c} function unkey(k){return k.split(",").map(Number)}

/* ===== Rendering ===== */
function probToColor(p){
  // 0 -> green (h=130), 1 -> red (h=0); tweak for visibility
  const hue = Math.round((1-p)*130); // 130..0
  const sat = 85; // %
  const lig = 40; // %
  return `hsl(${hue} ${sat}% ${lig}%)`;
}
function render(){
  const grid=document.getElementById("grid");
  grid.style.gridTemplateColumns=`repeat(${C},54px)`;
  grid.innerHTML="";
  for(let r=0;r<R;r++)for(let c=0;c<C;c++){
    const t=G[r][c];
    const b=document.createElement("button");
    b.className=`tile ${css(t)}`;
    b.innerHTML=`<div>${SYM[t]}</div><div class="prob"></div>`;
    b.title=toCoord(r,c);
    b.addEventListener("click",()=>{
      const mode=document.getElementById("mode").value;
      const activeType=document.getElementById("placeType").value;
      if(mode==="cycle"){
        G[r][c]=cycle(G[r][c]);
      } else {
        if(activeType==="PICK"){ // Eyedropper
          setTool(typeFromCell(G[r][c]));
          return; // don't paint while picking
        }
        G[r][c]=activeType;
      }
      PROB=null; // invalidate probabilities on edit
      clearHighlights();
      render();
    },{passive:true});
    grid.appendChild(b);
  }
  // overlay probs & heat map
  if(PROB){
    const tiles=[...grid.children];
    for(let i=0;i<tiles.length;i++){
      const r=Math.floor(i/C), c=i%C;
      const el=tiles[i].querySelector(".prob");
      if(G[r][c]===CARD.UNKNOWN){
        const p=PROB[r][c];
        el.textContent=(p*100).toFixed(0)+"%";
        // apply heat color
        tiles[i].style.backgroundColor = probToColor(p);
      } else {
        el.textContent="";
        tiles[i].style.backgroundColor = ""; // keep fixed type color
      }
    }
  }
}

function clearHighlights(){
  [...document.getElementById("grid").children].forEach(el=>el.classList.remove("hi"));
}

/* ===== Fixed/forbidden + hints ===== */
function fixedJ(){ const out=[]; for(let r=0;r<R;r++)for(let c=0;c<C;c++) if(G[r][c]===CARD.JERRY) out.push([r,c]); return out; }
function forb(){ const S=new Set(); const block=[CARD.MONEY,CARD.HINT,CARD.REACTIVATOR,CARD.EYE,CARD.MULTIPLIER,CARD.BLANK]; for(let r=0;r<R;r++)for(let c=0;c<C;c++) if(block.includes(G[r][c])) S.add(key(r,c)); return S; }

function check_no_adjacent(J){ for(const k of J){const [r,c]=unkey(k); for(const [nr,nc] of neighbors8(r,c)) if(J.has(key(nr,nc))) return false;} return true; }
function check_exists_row_empty(J){ for(let r=0;r<R;r++){let any=false; for(let c=0;c<C;c++) if(J.has(key(r,c))){any=true;break;} if(!any) return true;} return false; }
function check_each_row_at_least_one(J){ for(let r=0;r<R;r++){let any=false; for(let c=0;c<C;c++) if(J.has(key(r,c))){any=true;break;} if(!any) return false;} return true; }
function check_row_count(J,row,count){ let a=0; for(let c=0;c<C;c++) if(J.has(key(row,c))) a++; return a===count; }
function check_col_count(J,col,count){ let a=0; for(let r=0;r<R;r++) if(J.has(key(r,col))) a++; return a===count; }
function check_num_columns_with_jerry(J,k){ const S=new Set(); for(const kk of J){S.add(unkey(kk)[1])} return S.size===k; }
function check_adjacent_count(J,r,c,count){ let a=0; for(const [nr,nc] of neighbors8(r,c)) if(J.has(key(nr,nc))) a++; return a===count; }
function check_adjacent_to_eyes_total(J,count){ const eyes=[]; for(let r=0;r<R;r++)for(let c=0;c<C;c++) if(G[r][c]===CARD.EYE) eyes.push([r,c]); const adj=new Set(); for(const [er,ec] of eyes){ for(const [nr,nc] of neighbors8(er,ec)) if(J.has(key(nr,nc))) adj.add(key(nr,nc)); } return adj.size===count; }
function check_corner_count(J,count){ const corners=[key(0,0),key(0,C-1),key(R-1,0),key(R-1,C-1)]; let a=0; for(const k of corners) if(J.has(k)) a++; return a===count; }
function check_largest_grouping(J,size){ const seen=new Set(); function bfs(sr,sc){let q=[[sr,sc]],comp=0; seen.add(key(sr,sc)); while(q.length){const [r,c]=q.shift(); comp++; for(const [nr,nc] of neighbors8(r,c)){const kk=key(nr,nc); if(J.has(kk)&&!seen.has(kk)){seen.add(kk); q.push([nr,nc]);}}} return comp;} let mx=0; for(const kk of J){ if(!seen.has(kk)){const [r,c]=unkey(kk); mx=Math.max(mx,bfs(r,c));}} return mx===size; }
function check_all_in_3x3(J){ if(!J.size) return false; const rs=[],cs=[]; for(const k of J){const [r,c]=unkey(k); rs.push(r); cs.push(c);} const rmin=Math.min(...rs),rmax=Math.max(...rs),cmin=Math.min(...cs),cmax=Math.max(...cs); return (rmax-rmin+1)<=3 && (cmax-cmin+1)<=3; }
function check_mlr(J,r,c){ let L=0,Ri=0; for(const k of J){const [rr,cc]=unkey(k); if(rr===r){ if(cc<c)L++; else if(cc>c)Ri++; }} return L>Ri; }
function check_mrl(J,r,c){ let L=0,Ri=0; for(const k of J){const [rr,cc]=unkey(k); if(rr===r){ if(cc<c)L++; else if(cc>c)Ri++; }} return Ri>L; }
function check_mud(J,r,c){ let U=0,D=0; for(const k of J){const [rr,cc]=unkey(k); if(cc===c){ if(rr<r)U++; else if(rr>r)D++; }} return U>D; }
function check_mdu(J,r,c){ let U=0,D=0; for(const k of J){const [rr,cc]=unkey(k); if(cc===c){ if(rr<r)U++; else if(rr>r)D++; }} return D>U; }

function satisfies(J){
  if(J.size!==TOTAL) return false;
  for(let r=0;r<R;r++)for(let c=0;c<C;c++){const v=G[r][c],k=key(r,c); if(v===CARD.JERRY && !J.has(k)) return false; if([CARD.MONEY,CARD.HINT,CARD.REACTIVATOR,CARD.EYE,CARD.MULTIPLIER,CARD.BLANK].includes(v) && J.has(k)) return false;}
  for(const h of hints){
    switch(h.type){
      case"no_adjacent": if(!check_no_adjacent(J))return false; break;
      case"exists_row_empty": if(!check_exists_row_empty(J))return false; break;
      case"each_row_at_least_one": if(!check_each_row_at_least_one(J))return false; break;
      case"row_count": if(!check_row_count(J,h.row,h.count))return false; break;
      case"col_count": if(!check_col_count(J,h.col,h.count))return false; break;
      case"num_columns_with_jerry": if(!check_num_columns_with_jerry(J,h.k))return false; break;
      case"adjacent_count": if(!check_adjacent_count(J,h.r,h.c,h.count))return false; break;
      case"adjacent_to_eyes_total": if(!check_adjacent_to_eyes_total(J,h.count))return false; break;
      case"corner_count": if(!check_corner_count(J,h.count))return false; break;
      case"largest_grouping": if(!check_largest_grouping(J,h.size))return false; break;
      case"all_in_3x3": if(!check_all_in_3x3(J))return false; break;
      case"more_left_than_right": if(!check_mlr(J,h.r,h.c))return false; break;
      case"more_right_than_left": if(!check_mrl(J,h.r,h.c))return false; break;
      case"more_up_than_down": if(!check_mud(J,h.r,h.c))return false; break;
      case"more_down_than_up": if(!check_mdu(J,h.r,h.c))return false; break;
    }
  }
  return true;
}

/* ===== Monte Carlo ===== */
function sampleValid(){
  const fixed=new Set(fixedJ().map(([r,c])=>key(r,c)));
  if(fixed.size>TOTAL) return null;
  const F=forb();
  const cand=[]; for(let r=0;r<R;r++)for(let c=0;c<C;c++){const k=key(r,c); if(!F.has(k)) cand.push([r,c]);}
  for(const k of fixed){ if(!cand.some(([r,c])=>key(r,c)===k)) return null; }
  const rest=cand.filter(([r,c])=>!fixed.has(key(r,c)));
  shuffle(rest);
  const J=new Set(fixed);
  function quick(){ // light prune
    if(hints.some(h=>h.type==="no_adjacent")){
      for(const kk of J){const [r,c]=unkey(kk); for(const [nr,nc] of neighbors8(r,c)) if(J.has(key(nr,nc))) return false;}
    }
    if(hints.some(h=>h.type==="all_in_3x3") && J.size){
      const rs=[],cs=[]; for(const kk of J){const [r,c]=unkey(kk); rs.push(r); cs.push(c);}
      const rmin=Math.min(...rs),rmax=Math.max(...rs),cmin=Math.min(...cs),cmax=Math.max(...cs);
      if((rmax-rmin+1)>3||(cmax-cmin+1)>3) return false;
    }
    return true;
  }
  let back=0;
  function dfs(i){
    if(back>10000) return false;
    if(J.size===TOTAL) return satisfies(J);
    if(i>=rest.length) return false;
    const [r,c]=rest[i]; const k=key(r,c);
    J.add(k); if(quick()&&dfs(i+1)) return true; J.delete(k);
    if(dfs(i+1)) return true;
    back++; return false;
  }
  return dfs(0)?J:null;
}
function shuffle(a){ for(let i=a.length-1;i>0;i--){const j=(Math.random()* (i+1))|0; [a[i],a[j]]=[a[j],a[i]];} }
function monte(samples){
  const cnt=[...Array(R)].map(()=>Array(C).fill(0));
  let found=0,tr=0;
  for(let s=0;s<samples;s++){
    tr++;
    const J=sampleValid();
    if(!J) continue;
    found++;
    for(const kk of J){const [r,c]=unkey(kk); cnt[r][c]++; }
  }
  const prob=[...Array(R)].map(()=>Array(C).fill(0));
  for(let r=0;r<R;r++)for(let c=0;c<C;c++) prob[r][c]=found?cnt[r][c]/found:0;
  return {prob, hit: found/Math.max(1,tr)};
}
function recommend(prob,k){
  const list=[];
  for(let r=0;r<R;r++)for(let c=0;c<C;c++) if(G[r][c]===CARD.UNKNOWN) list.push({r,c,p:prob[r][c]});
  list.sort((a,b)=>a.p-b.p||a.r-b.r||a.c-b.c);
  return list.slice(0,Math.max(0,k));
}

/* ===== Hints UI ===== */
function addHintUI(){
  const t=document.getElementById("hintType").value;
  try{
    if(["no_adjacent","exists_row_empty","each_row_at_least_one","all_in_3x3"].includes(t)){ hints.push({type:t}); }
    else if(t==="row_count"){
      const rowV=document.getElementById("hp_row")?.value.trim();
      const row = /^[A-Za-z]$/.test(rowV)? rowV.toUpperCase().charCodeAt(0)-65 : parseInt(rowV,10);
      const count=parseInt(document.getElementById("hp_count").value,10);
      hints.push({type:t,row,count});
    } else if(t==="col_count"){
      let col=parseInt(document.getElementById("hp_col").value,10); if(col>=1) col-=1;
      const count=parseInt(document.getElementById("hp_count").value,10);
      hints.push({type:t,col,count});
    } else if(t==="num_columns_with_jerry"){
      const k=parseInt(document.getElementById("hp_k").value,10); hints.push({type:t,k});
    } else if(t==="adjacent_count"){
      const cell=document.getElementById("hp_cell").value; const [r,c]=parseCell(cell);
      const count=parseInt(document.getElementById("hp_count").value,10);
      hints.push({type:t,r,c,count});
    } else if(t==="adjacent_to_eyes_total"){
      const count=parseInt(document.getElementById("hp_count").value,10); hints.push({type:t,count});
    } else if(t==="corner_count"){
      const count=parseInt(document.getElementById("hp_count").value,10); hints.push({type:t,count});
    } else if(t==="largest_grouping"){
      const size=parseInt(document.getElementById("hp_size").value,10); hints.push({type:t,size});
    } else if(["more_left_than_right","more_right_than_left","more_up_than_down","more_down_than_up"].includes(t)){
      const cell=document.getElementById("hp_cell").value; const [r,c]=parseCell(cell);
      hints.push({type:t,r,c});
    }
    renderHints();
  }catch(e){ alert("Hint error: "+e.message); }
}
function renderHintParams(){
  const t=document.getElementById("hintType").value;
  const box=document.getElementById("hintParams"); box.innerHTML="";
  function field(id,label,ph){ box.insertAdjacentHTML("beforeend",`<label>${label}<br><input id="${id}" placeholder="${ph}" style="width:140px"></label>`); }
  if(t==="row_count"){ field("hp_row","Row (A or 0)","A"); field("hp_count","Count","2"); }
  else if(t==="col_count"){ field("hp_col","Col (1 or 0)","3"); field("hp_count","Count","1"); }
  else if(t==="num_columns_with_jerry"){ field("hp_k","K cols","4"); }
  else if(t==="adjacent_count"){ field("hp_cell","Cell (A1 or 'r c')","B5"); field("hp_count","Count","2"); }
  else if(t==="adjacent_to_eyes_total"){ field("hp_count","Unique adj to EYE","3"); }
  else if(t==="corner_count"){ field("hp_count","Corners count","1"); }
  else if(t==="largest_grouping"){ field("hp_size","Largest group size","2"); }
  else if(["more_left_than_right","more_right_than_left","more_up_than_down","more_down_than_up"].includes(t)){ field("hp_cell","Cell (A1 or 'r c')","C4"); }
}
function renderHints(){
  const list=document.getElementById("hintList"); list.innerHTML="";
  hints.forEach((h,i)=>{
    const d=document.createElement("div"); d.className="card"; d.style.padding="6px";
    d.innerHTML=`<div style="display:flex;justify-content:space-between;gap:8px;align-items:center">
      <div style="font-size:14px">${JSON.stringify(h)}</div>
      <button class="btn" style="background:#475569">remove</button></div>`;
    d.querySelector("button").onclick=()=>{ hints.splice(i,1); renderHints(); };
    list.appendChild(d);
  });
}

/* ===== Picks ===== */
function showPicks(kOverride=null){
  if(!PROB){ alert("Run solver first."); return; }
  const k = kOverride ?? (parseInt(document.getElementById("k").value,10)||3);
  const picks=recommend(PROB,k);
  const area=document.getElementById("picks"); area.innerHTML="";
  clearHighlights();
  picks.forEach(p=>{
    const b=document.createElement("button"); b.className="btn"; b.style.background="#0f766e";
    b.textContent=`${toCoord(p.r,p.c)}  (${(p.p*100).toFixed(1)}%)`;
    b.onclick=()=>{
      const idx=p.r*C+p.c;
      const tile=[...document.getElementById("grid").children][idx];
      tile.classList.add("hi"); tile.scrollIntoView({behavior:"smooth",block:"center",inline:"center"});
    };
    area.appendChild(b);
    // highlight immediately
    const idx=p.r*C+p.c;
    const tile=[...document.getElementById("grid").children][idx];
    tile.classList.add("hi");
  });
}

/* ===== Controls wiring ===== */
document.getElementById("apply").onclick=()=>{ R=+rows.value; C=+cols.value; TOTAL=+totalJ.value; makeG(); hints=[]; PROB=null; render(); renderHints(); document.getElementById("hit").textContent=""; document.getElementById("picks").innerHTML=""; };
document.getElementById("run").onclick=()=>{
  const s=+document.getElementById("samples").value||800;
  const {prob,hit}=monte(s);
  PROB=prob;
  document.getElementById("hit").textContent=`Success ${(hit*100).toFixed(1)}%`;
  render();
  // auto-show and highlight top 3 picks
  showPicks(3);
};
document.getElementById("picksBtn").onclick=()=>showPicks();
document.getElementById("wipe").onclick=()=>{ rows.value=3; cols.value=8; totalJ.value=4; document.getElementById("apply").click(); };
document.getElementById("hintType").onchange=renderHintParams;
document.getElementById("addHint").onclick=addHintUI;

/* ===== Tool buttons (incl. Eyedropper) ===== */
const toolButtons = {
  toolPick: "PICK",
  toolDot: "UNKNOWN",
  toolMoney: "MONEY",
  toolJerry: "JERRY",
  toolHint: "HINT",
  toolReac: "REACTIVATOR",
  toolEye: "EYE",
  toolMult: "MULTIPLIER",
  toolBlank: "BLANK",
};
function typeFromCell(t){ return t; }
function setTool(type){
  // force "Place Selected" mode
  document.getElementById("mode").value = "place";
  document.getElementById("placeType").value = type;
  // visual active state
  for (const id of Object.keys(toolButtons)){
    const el = document.getElementById(id);
    el.classList.toggle("active", toolButtons[id] === type);
  }
}
for (const [id, type] of Object.entries(toolButtons)){
  document.getElementById(id).onclick = ()=> setTool(type);
}

/* init */
function renderHintParams(){ /* already defined above; re-run to mount initial fields */ }
makeG(); render(); renderHintParams();
setTool("UNKNOWN");
</script>
</body>
</html>